---
sidebar_position: 1
title: 오브젝트 - 조영호
---

# <span style={{color: '#4fddbf'}}> 오브젝트 - 조영호 </span>

## 1장

- 소프트웨어 모듈의 세 가지 목적
    1. 실행 중에 제대로 동작하는 것.
    2. 변경에 용이하여야한다.
    3. 코드를 읽는 사람과 쉽게 의사소통이 가능해야한다.

    by. 로버트 마틴- 클린 소프트웨어: 애자일 원칙과 패턴, 그리고 실천 방법

- 객체지향적인 설계(↔ 절차지향)를 통해 위의 목적들을 충족시킬 수 있다.
    - 1장의 예제에서 각 객체는 데이터들만을 보관하고, 로직은 하나의 객체 메소드에서 짜여져있는 것을 각각의 객체에 챔임을 분리하여 기능을 구현하고 의존성을 최대한 낮추는 방향으로 분리하여 객체들끼리 상호작용하게끔 코드를 개선함.
    - 응집도를 높이고, 결합도를 낮추었다.
- 결국 설계는 트레이드오프의 산물이다. 어떤 경우에도 모든 사람들을 만족시킬 수 있는 설계를 만들 수는 없다. / 설계는 균형의 예술이다. 이러한 트레이드오프 과정이 설계를 어려우면서도 흥미진진한 작업으로 만든다.

## 2장

- 영화예매시스템을 예제로 앞으로 이해하게 될 다양한 주제들을 살펴볼 것.
- 진정한 객체지향 패러딤으로의 전환은 ‘클래스’가 아닌 ‘객체’에 초점을 맞추는 것이다.
    - 어떤 클래스가 필요한지를 고민하기 전에 어떤 객체들이 필요한지 고민하라. 클래스는 공통적인 상태와 행동을 공유하는 객체들을 추상화한 것이다.
    - 객체를 독립적인 존재가 아니라 기능을 구현하기 위해 협력하는 공동체의 일원으로 봐라.
- 클래스 구현하기.
    - Screening
        - 인스턴스 변수의 가시성은 private, 메서드의 가시성은 public
        - 클래스의 경계를 구분 짓는 것이 중요하다. 그 이유는 경계의 명확성이 객체의 자율성을 보장하기 때문이다. 또 더 중요한 이유로 프로그래머에게 구현의 자유를 제공하기 때문이다.
        - 일반적으로 객체의 상태는 숨기고 행동만 외부에 공개해야한다.
        - 객체의 자율성을 보장 - 객체지향의 핵심은 스스로 상태를 관리하고, 판단하고, 행동하는 자율적인 객체들의 공동체를 구성하는 것이다. 객체가 자율적으로 행동하려면 외부의 간섭을 최소화 해야할 것이며 외부의 간섭을 최소화하기 위해서 경계를 구분짓는다.
        - 프로그래머에게 구현의 자유를 제공 - 경계를 구분짓음으로써 클래스를 구현하는 입장에서는 클래스 내부에 public(외부에서 사용되는 것들)을 제외하고 private은 내부에서만 사용됨이 보장되기 때문에 외부에 대한 영향을 고려하지 않고 자유롭게 구현 및 수정이 가능해진다. 클래스를 사용하는 클라이언트 프로그래머 입장에서는 내부 구현은 무시한채 인터페이스만 알고 있어도 클래스를 사용할 수 있게 된다.
        - 경계를 짓는 것에 있어서(객체의 변경을 관리하는 기법) 다양한 방법이 있으며 대표적인 것이 ‘접근 제어’
    - Reservation
        - 객체들 사이에 이뤄지는 상호작용 - 협력(Collaboration)
        - 메시지와 메스드를 구분하는 것은 중요하다. 메시지와 메서드의 구분에서부터 다형성의 개념이 출발한다.
    - Movie, DiscountPolicy, DiscountCondition
        - 상속, 구현, 다형성, 추상화,
        - 설계가 유연해질수록 코드를 이해하고 디버깅하기는 점점 더 여려워지며, 유연성을 억제하면 코드를 이해하고 디버깅하기는 쉬워지지만 재사용성과 확장 가능성은 낮아진다. 유연성과 가독성 사이에서 트레이드 오프가 존재.
    - 코드 재사용의 관점에서 상속과 합성 (p70)
        - 코드 재사용은 어떠한 객체에서 다른 객체에 의존하여 특정 메소드를 사용하는 것도 재사용.
        - 상속은 캡슐화를 위반하며 설계를 유연하지 못하게 만듬 (부모 클래스와 자식 클래스의 결합도가 강해서)
        - 합성은 상속이 가지는 두 가지 문제점을 모두 해결한다.
        - 상속을 절대 사용하지 말라는 것은 아니며, 코드 재사용을 위해서는 합성을 선호하는 것이 옳으며, 다형성을 위해 인터페이스를 재사용하는 경우에는 상속과 합성을 조합해서 사용할 수 밖에 없다.

## 3장 - 역할, 책임, 협력

- 객체지향 패러다임의 관점에서 핵심은 역할, 책임, 협력이다. 클래스, 상속, 지연 바인딩 등은 구현 측면의 것들.
- 객체지향 원칙을 따르는 어플리케이션의 제어 흐름은 어떤 하나의 객체에 의해 통제되지 않고 다양한 객체들 사이에 균형 있게 분배되는 것이 일반적.
    - 이 과정에서 객체들이 수행하는 상호작용을 ‘협력’
    - 객체가 협력에 참여하기 위해 수행하는 로직은 ‘책임’
    - 객체들이 협력 안에서 수행하는 책임들이 모여 객체가 수행하는 ‘역할’을 구성.
- 협력
    - 협력이란 어떤 객체가 다른 객체에게 무엇인가를 요청하는 것 (메세지 전송(message sending))
        - 메세지를 수신한 객체는 메서드를 실행해 요청에 응답한다.
        - 여기서 포인트는 객체가 요청받은 메시지를 처리할 방법을 스스로 선택한다는 것이며, 이것은 객체가 자신의 일을 스스로 처리할 수 있는 자율적인 존재라는 것을 의미한다.
    - 두 객체가 상호작용을 통해 더 큰 책임을 수행.
    - 객체 사이의 협력을 설계할 때는 객체를 서로 분리된 인스턴스가 아닌 협력하는 파트너로 인식.
    - 객체의 행동(method)는 협력이 결정하며, 객체의 상태(멤버 변수)는 행동이 결정한다.